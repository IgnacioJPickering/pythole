r"""This module contains a python implementation for the
calculation of the energy of induced dipoles on a system of fixed point charges
with a given per-point polarizability using:

- The Applequist expression
- The Thole method
- The "Warshel" approximation, an approximate method that disregards the effect
  of the field generated by the dipole itself (with and without an empirical
  permitivity). (This was probably first proposed by Warshel and Levitt, and is
  the method used in Santi's paper).
"""
import typing as tp
import shutil

import numpy as np
import h5py

from pythole.utils import (
    HomoEfield,
    znums_from_alphas,
    check_shapes_and_filter_dummy_entries,
    repeat_invert_and_reshape_atomic_alphas_to_3a3a,
    reduce_eff_alpha_3a3a_to_molecular_alpha_3x3,
    repeat_and_reshape_atomic_alphas_to_3a,
    reshape_dipole_field_to_3a3a,
    reshape_efield_to_3a,
    make_homo_efield,
)
from pythole.dipole_io import (
    write_molecular_alpha_file,
    write_atomic_alphas_file,
    write_dipole_file,
    write_efield_file,
    write_xyz_file,
)
from pythole.dipoles import (
    DipoleKind,
    MolecularAlphaKind,
    EfieldKind,
    TholeDampingArgs,
    calc_pair_dipole_field_matrix,
    calc_dipoles,
)
from pythole.databases import _IN_DATA_DIR, _OUT_DATA_DIR


db = h5py.File(_IN_DATA_DIR / "thole_data.h5")
formula = "C2H5N1O2"
conformations = db[formula]

# (Atomic) coordinates, polarizabilites and electric field, all values are float64
coords = conformations["coordinates"][:]
alphas = conformations["polariz_free"][:]
external_efield = conformations["e_field"][:]

homo_efield: tp.Optional[HomoEfield] = HomoEfield(x=0.05, y=0.05, z=0.05)
# homo_efield = None

coords, alphas, external_efield = check_shapes_and_filter_dummy_entries(
    coords, alphas, external_efield
)

# Overwrite field with a homogeneous electric field
if homo_efield is not None:
    external_efield = make_homo_efield(coords, homo_efield)

znums = znums_from_alphas(alphas)

inv_alphas_3a3a = repeat_invert_and_reshape_atomic_alphas_to_3a3a(alphas)
external_efield_3a = reshape_efield_to_3a(external_efield)
alphas_3a = repeat_and_reshape_atomic_alphas_to_3a(alphas)

# The inverse "effective" polarization matrix, B
# satisfies B_3a3a @ dipole_3a = external_efield_3a,
# It is calculated for the three methods

# Applequist
apple_pair_matrix = calc_pair_dipole_field_matrix(coords)
apple_pair_matrix_3a3a = reshape_dipole_field_to_3a3a(apple_pair_matrix)
# Effective alpha
apple_eff_alpha_matrix_3a3a = np.linalg.inv(apple_pair_matrix_3a3a + inv_alphas_3a3a)
# Polarizability
apple_molecular_alpha = reduce_eff_alpha_3a3a_to_molecular_alpha_3x3(
    apple_eff_alpha_matrix_3a3a
)
apple_molecular_alpha_diag = np.linalg.eigh(apple_molecular_alpha)
apple_evalues = apple_molecular_alpha_diag.eigenvalues
apple_evectors = apple_molecular_alpha_diag.eigenvectors  # evectors are in columns
# Dipoles
apple_dipoles = calc_dipoles(apple_eff_alpha_matrix_3a3a, external_efield_3a)

# Thole
args = TholeDampingArgs(alphas=alphas, damp_factor=1.0)
thole_pair_matrix = calc_pair_dipole_field_matrix(coords, thole_damping_args=args)
thole_pair_matrix_3a3a = reshape_dipole_field_to_3a3a(thole_pair_matrix)
# Effective alpha
thole_eff_alpha_matrix_3a3a = np.linalg.inv(thole_pair_matrix_3a3a + inv_alphas_3a3a)
# Polarizability
thole_molecular_alpha = reduce_eff_alpha_3a3a_to_molecular_alpha_3x3(
    thole_eff_alpha_matrix_3a3a
)
thole_molecular_alpha_diag = np.linalg.eigh(thole_molecular_alpha)
thole_evalues = thole_molecular_alpha_diag.eigenvalues
thole_evectors = thole_molecular_alpha_diag.eigenvectors
# Dipoles
thole_dipoles = calc_dipoles(thole_eff_alpha_matrix_3a3a, external_efield_3a)

# Warshel (this is just a constant 1 / eps matrix)
warshel_eps = 1.0
warshel_dipoles = (alphas_3a / warshel_eps * external_efield_3a).reshape(*coords.shape)

#  The molecular polarizability only really makes sense as a response to
#  homogeneous fields
# TODO: Check if the warshell expression makes sense
warshel_molecular_alpha = np.sum(alphas, -1).reshape(-1, 1, 1) * np.expand_dims(
    np.eye(3), 0
)

for j, (
    conf_coords,
    conf_znums,
    conf_apple,
    conf_thole,
    conf_warshel,
    conf_external_efield,
    conf_alphas,
    conf_thole_evectors,
    conf_thole_evalues,
    conf_apple_evectors,
    conf_apple_evalues,
) in enumerate(
    zip(
        coords,
        znums,
        apple_dipoles,
        thole_dipoles,
        warshel_dipoles,
        external_efield,
        alphas,
        thole_evectors,
        thole_evalues,
        apple_evectors,
        apple_evalues,
    )
):
    dir_ = _OUT_DATA_DIR / formula
    dir_ /= str(j).zfill(len(str(coords.shape[0])) + 1)
    if dir_.is_dir():
        shutil.rmtree(dir_)
    dir_.mkdir(exist_ok=False, parents=True)
    write_xyz_file(dir_, conf_coords, conf_znums)
    write_dipole_file(dir_, conf_coords, conf_apple, DipoleKind.APPLEQUIST)
    write_dipole_file(dir_, conf_coords, conf_thole, DipoleKind.THOLE)
    write_dipole_file(dir_, conf_coords, conf_warshel, DipoleKind.WARSHEL)
    write_efield_file(dir_, conf_coords, conf_external_efield, EfieldKind.EXTERNAL)
    write_atomic_alphas_file(dir_, conf_coords, conf_alphas)
    write_molecular_alpha_file(
        dir_,
        conf_coords,
        conf_thole_evectors,
        conf_thole_evalues,
        MolecularAlphaKind.THOLE,
    )
    write_molecular_alpha_file(
        dir_,
        conf_coords,
        conf_apple_evectors,
        conf_apple_evalues,
        MolecularAlphaKind.APPLEQUIST,
    )
